<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>The Case of Multiple Repos</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <style>
    :root { --w: 42rem; }
    body { margin: 2rem auto; padding: 0 1rem; max-width: var(--w); line-height: 1.6; }
    header, footer { margin: 1rem 0 2rem; }
    nav a { margin-right: .75rem; text-decoration: underline; }
    h1, h2, h3 { line-height: 1.2; }
    pre, code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    img, video { max-width: 100%; height: auto; }
    hr { border: 0; border-top: 1px solid #ccc; }
  </style>
</head>
<body>
  <header>
    <h1><a href="..">Rutger's Blog</a></h1>
  </header>

  <main>
    
  <h1 id="the-case-of-multiple-repos">The Case of Multiple Repos</h1>
<p><em>2025-11-27</em></p>
<p>**Your whole project should be in a single git repo!</p>
<p>Really, it does! Multiple repos make teams slow and systems error prone.</p>
<p>If the<code>frontend</code>, <code>backend</code>, <code>infrastructure</code>, <code>computation_service</code>, <code>data_pipelines</code>, <code>forecast_model</code> should be working together they should be in a single repo. Too often have I seen this not being case, and the effects are more costly and insidious than you'd think at first.</p>
<p>Let's take <code>frontend</code> and <code>backend</code>, now this might be less common these days because fullstack developers will generally not create two repositories (for reasons I will go into later). But how do you make sure your frontend and backend work correctly together if they are in separate repositories?</p>
<p>You will be adding another layer of version control.</p>
<p>Let's say a new feature is implemented in separate frontend and backend repos. How do you deploy it? You make sure the new backend is deployed before the new frontend, right? Next you'll be wanting to add tags with a release number so you remember which frontend commit relies on which backend commit.</p>
<p>These release tags are the second layer of version control. One that you are managing manually.</p>
<p>Versioned releases are great - if you are providing a library or a public API. But if this is an <em>application</em>, versions are really only useful for release notes and bug reports.  </p>
<p>The downsides and costs of second-layer versioning should not be underestimated. It goes further than the frustrated frontender that forgot to update the backend repository again. Crucial development processes become more complicated: 
- How do you manage deploying the different subsystems?
- How do you run the complete system locally?
- How do you test end-to-end?
- How do you do code review over a complete feature?
These issues will slow down your team; There is more to manage, you will find bugs later and will have a whole class of bugs that are not possible in a single repo.</p>
<p>And there are other, less obvious problems. Separate repositories create knowledge silos and ownership silos, and lower overall collaboration. They increase the friction of cross-functional work. Developers don't naturally see merge requests for other parts of a system and will be less inclined to get involved.</p>
<p>In a way, it is an example of Conway's Law: System architecture follows organizational structure. This is especially a risk in new teams or new companies. Developers don't know each other well yet. The team is not yet a real team. It may feel natural for each developer to start a git repository for their own subdomain.</p>
<p>Another reason this might happen is because developers are unsure where to put something new. They might not feel enough ownership over the project root, or don't feel  comfortable reaching out to discuss the placement of this new part.</p>
<p>You don't have to go full monorepo, Google-style. Instead ideally you look at what parts are connected, and put as many of those connected parts in a single repository, until you actually reach other practical limits. I'm not sure what those limits are or where they lie, but they are certainly a lot further away than commonly assumed. Hit those limits first and <em>then</em> think about where a second layer of versioning will be worth the hassle.</p>
<p>These days, frontend and backend is more likely to be done by fullstack developers. They will use a single repo for both, because they won't feel this friction in collaboration. But infrastructure engineers, data scientists, and data engineers are still likely to be working in their own repositories. Or each data model may have its own repository, with its own full set of project dependencies, Makefiles, and CI/CD. Yet another tiny little project that needs managing. </p>
<p>If you find yourself dealing with integration errors, or versioning to prevent integration errors: Consider merging repositories.</p>
<p>A good counter-argument is:</p>
<blockquote>
<p>If there is a critical issue in one part of the system, we cannot deploy other parts of the system.</p>
</blockquote>
<p>This is a real issue, and one of the possible limits. Let's assume we did a rollback to a stable version of the project because the backend fails in the new version. But the data scientists want to deploy their new model. They either have to:
- Wait until the issue is resolved
- Rebase their code on the older stable version
- Have a separate deployment process</p>
<p>Although it makes sense to have single deployment process for a project in a single repository, it is not required. Infrastructure deployments will very likely require their own flow. And data pipelines and data models could have their own flows as well.
Having separate deployment flows will alleviate the dependency pain, but it reintroduces the risk of misaligned versions. This is inherent to the problem. You can't be both independent <em>and</em> always be aligned on versions.</p>

  </main>

</body>
</html>